#!/usr/bin/env python
# coding: utf-8

# In[18]:


import numpy as np
from astropy.io import fits
import matplotlib.pyplot as plt


# In[19]:


hdu = fits.open('galSpecLine-dr8.fits')


# In[20]:


#defining emission line varaibles
ha = hdu[1].data['H_ALPHA_FLUX']
ha_err = hdu[1].data['H_ALPHA_FLUX_ERR']
hb = hdu[1].data['H_BETA_FLUX']
hb_err = hdu[1].data['H_BETA_FLUX_ERR']
n2 = hdu[1].data['NII_6584_FLUX']
n2_err = hdu[1].data['NII_6584_FLUX_ERR']
o3 = hdu[1].data['OIII_5007_FLUX']
o3_err = hdu[1].data['OIII_5007_FLUX_ERR']


# In[21]:


ha = np.array(ha)
ha_err = np.array(ha_err)
hb = np.array(hb)
hb_err = np.array(hb_err)
n2 = np.array(n2)
n2_err = np.array(n2_err)
o3 = np.array(o3)
o3_err = np.array(o3_err)


# In[22]:


ha = ha[ha != 0]
ha_err = ha_err[ha_err != 0]
hb = hb[hb != 0]
hb_err = hb_err[hb_err != 0]
n2 = n2[n2 != 0]
n2_err = n2_err[n2_err != 0]
o3 = o3[o3 != 0]
o3_err = o3_err[o3_err != 0]


# In[23]:


ha, ha_err = zip(*zip(ha, ha_err))
hb, hb_err = zip(*zip(hb, hb_err))
n2, n2_err = zip(*zip(n2, n2_err))
o3, o3_err = zip(*zip(o3, o3_err))


# In[24]:


print(len(ha))
print(len(ha_err))
print(len(hb))
print(len(hb_err))


# In[25]:


ha_new = np.floor_divide(ha, ha_err)
hb_new = np.floor_divide(hb, hb_err)
n2_new = np.floor_divide(n2, n2_err)
o3_new = np.floor_divide(o3, o3_err)


# In[26]:


ha_new = ha_new[np.where(ha_new > 10)]
hb_new = hb_new[np.where(hb_new > 10)]
n2_new = n2_new[np.where(n2_new > 10)]
o3_new = o3_new[np.where(o3_new > 10)]


# In[27]:


print(len(ha_new))
print(len(hb_new))
print(len(n2_new))
print(len(o3_new))


# In[28]:


o3_new, ha_new = zip(*zip(o3_new, ha_new))
o3_new, hb_new = zip(*zip(o3_new, hb_new))
o3_new, n2_new = zip(*zip(o3_new, n2_new))


# In[29]:


print(len(ha_new))
print(len(hb_new))
print(len(n2_new))
print(len(o3_new))


# In[36]:


import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits

#log([NII]/Ha) is on the x-axis
#log([OIII]/Hb) is on the y-axis
def BPT_kaufmann():
    x=np.linspace(-2,0,500)
    logdivline=(0.61/(x-0.05))+1.3
    return x, logdivline

#log([NII]/Ha) is on the x-axis
#log([OIII]/Hb) is on the y-axis
def BPT_kewley():
    x=np.linspace(-2,0.46,500)
    logdivlineK=(0.61/(x-0.47))+1.19
    return x, logdivlineK

#log([NII]/Ha) is on the x-axis
#log([OIII]/Hb) is on the y-axis
def BPT_liner():
    x=np.linspace(-0.133638005,0.75,100)
    y=2.1445*x+0.465
    return x,y

def plot_BPT(NII,halpha,OIII,hbeta,fig=None,**kwargs):
    halpha=np.array(halpha,dtype=float)
    NII=np.array(NII,dtype=float)
    hbeta=np.array(hbeta,dtype=float)
    OIII=np.array(OIII,dtype=float)
    n2ha=np.log10(NII/halpha)
    o3hb=np.log10(OIII/hbeta)
    kaufmann=BPT_kaufmann()
    kewley=BPT_kewley()
    liner=BPT_liner()
    plt.scatter(n2ha,o3hb,**kwargs)
    plt.plot(kaufmann[0],kaufmann[1],c='b')
    plt.plot(kewley[0],kewley[1],c='r',linestyle='--')
    plt.plot(liner[0],liner[1],c='w',linestyle='-.')
    plt.xlim(-2,1)
    plt.ylim(-1.5,1.5)
    plt.xlabel(r'$log_{10}($[NII]/H$\alpha)$')
    plt.ylabel(r'$log_{10}($[OIII]/H$\beta)$')
    return


# In[37]:


NII=n2_new
halpha=ha_new
OIII=o3_new
hbeta=hb_new

plot_BPT(NII,halpha,OIII,hbeta,c='g',s=1,alpha=0.2)


# In[ ]:




